<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hub Town: de uma segunda-feira caótica a uma arquitetura confiável - Christian Mulato Dev Blog</title>
    <meta name="description" content="Arquitetura do Hub Town: ingestão resiliente, leitura consistente, KPIs confiáveis.">
    <meta name="author" content="Christian Mulato">
    <meta name="keywords" content="Java, Spring Boot, RabbitMQ, PostgreSQL, Arquitetura, Marketplace">
    <link rel="stylesheet" href="assets/css/main.css">
    <link rel="stylesheet" href="assets/css/article.css">
    <link rel="stylesheet" href="assets/css/highlight.css">
</head>
<body>
    <header class="site-header">
        <div class="container">
            <h1><a href="../index.html">Christian Mulato Dev Blog</a></h1>
            <nav class="main-nav">
                <a href="../index.html">Início</a>
                <a href="#sobre">Sobre</a>
            </nav>
        </div>
    </header>
    <main class="main-content">
        <div class="container">
            <article class="post">
                <header class="post-header">
                    <h1 class="post-title">Hub Town: de uma segunda-feira caótica a uma arquitetura confiável</h1>
                    <div class="post-meta">
                        <time datetime="2025-10-12">12/10/2025</time>
                        <span class="post-author">Por Christian Mulato</span>
                    </div>
                </header>
        <div class="post-content">
          <!-- conteúdo original do artigo abaixo -->
          <p><img class="hero-image" src="assets/img/2025_10_12_IMAGE_001.png" alt="Arquitetura de ingestão e leitura do Hub Town"></p>
          <p><em>Figura — Arquitetura de ingestão (Spring Boot) + mensageria (RabbitMQ) + persistência (PostgreSQL) + leitura/Frontend.</em></p>
          
                    <p>Quando o comércio local começa a vender em múltiplos marketplaces, a segunda-feira não perdoa: números que não batem, relatórios que chegam tarde, decisões que dependem de dados que mudam a cada F5. O Hub Town nasceu para transformar esse cenário em rotina previsível: ingestão resiliente, leitura consistente, KPIs confiáveis.</p>
                    <p>Este artigo é um relato de descoberta: qual é o menor conjunto de decisões técnicas que nos dá escala, confiabilidade e clareza? E como aplicá-las, passo a passo, sem sacrificar o que já funciona no frontend?</p>
                    <h2>A ideia que mudou o jogo</h2>
                    <p>Separar o que é caótico do que precisa ser previsível.</p>
                    <ul>
                      <li><b>Caótico:</b> integrações com marketplaces (picos, falhas, formatos diferentes). Onde aceitamos variabilidade e erramos para frente com retry, DLQ e circuit breakers.</li>
                      <li><b>Previsível:</b> leitura para o frontend. Onde contratos são estáveis, consultas são rápidas e o dado é único e normalizado.</li>
                    </ul>
                    <p>Daí emergiu nossa arquitetura em cinco blocos:</p>
                    <ol>
                      <li>Ingestão (Spring Boot) para falar com cada marketplace, agendar polling e receber webhooks, normalizando tudo para um formato canônico.</li>
                      <li>Mensageria (RabbitMQ) para desacoplar ritmos: a ingestão publica eventos; consumidores processam no seu tempo, com retries e DLQ.</li>
                      <li>Persistência (PostgreSQL) como fonte única de verdade, com idempotência por chave natural e histórico de status.</li>
                      <li>API de Leitura que consulta exclusivamente o banco, oferecendo paginação, busca unificada e estatísticas.</li>
                      <li>Frontend (React/Vite) que só conversa com a API interna, nunca com os marketplaces.</li>
                    </ol>
                    <h2>A jornada de um pedido (do clique ao KPI)</h2>
                    <ol>
                      <li>O marketplace dispara um webhook (ou a ingestão busca via polling). O serviço Spring Boot valida, traduz e normaliza.</li>
                      <li>Uma mensagem canônica é publicada no RabbitMQ. Se algo falha, entra em retry; se persistir, vai para a DLQ e fica visível.</li>
                      <li>Um consumer Spring Boot lê a mensagem, aplica idempotência (marketplace + original_order_id) e faz UPSERT no PostgreSQL.</li>
                      <li>A API de Leitura consulta o banco com filtros e paginação padronizados. Nada de surpresas; só dados consistentes.</li>
                      <li>O frontend exibe abas por marketplace, busca unificada e KPIs — sempre com o mesmo contrato de resposta.</li>
                    </ol>
                    <h3>Mapa mental (versão textual, hierárquica)</h3>
                    <pre>
- Hub Town
  - Objetivo
    - Leitura previsível e confiável para o frontend a partir de dados normalizados.
  - Ingestão (Spring Boot)
    - Responsabilidades: adapters por marketplace, polling/webhooks, normalização.
    - Decisões: schema canônico, publisher confirms, resiliência (retry/backoff, circuit breaker, timeouts).
    - Qualidade: idempotência no produtor quando aplicável; métricas de taxa de ingestão e latência.
  - Mensageria (RabbitMQ)
    - Exchange: topic hubtown.orders.exchange.
    - Filas: *.process por marketplace; *.dlq por marketplace; filas de retry com TTL+DLX.
    - QoS: ack manual, prefetch 10–20, concorrência 2–4 por fila; observabilidade de backlog e x-death.
  - Persistência (PostgreSQL)
    - Modelo: orders, buyers, addresses, order_status_history, marketplaces.
    - Regras: idempotência por (marketplace + original_order_id); “última versão vence” por occurred_at/versão.
    - Performance: índices para busca/paginação; UPSERT consistente.
  - API de Leitura
    - Rotas: listagem por marketplace, busca unificada, estatísticas.
    - Contratos: paginação (data, total, currentPage, totalPages) e filtros estáveis.
    - Objetivo: respostas rápidas e previsíveis, sempre a partir do DB.
  - Frontend (React/Vite)
    - Consumo: apenas a API interna; base URL por variável de ambiente.
    - UX: abas por marketplace, visão “Todos”, KPIs.
  - Segurança e Configuração
    - Segredos fora do código; CORS/headers; auditoria quando aplicável.
  - Observabilidade
    - Logs estruturados com traceId/correlationId; métricas e dashboards por domínio.
  - Operação
    - Backups do DB, retenção de mensagens, DLQ visível, reprocessamento controlado e playbooks.
                    </pre>
                    <h2>Decisões que protegem a experiência</h2>
                    <ul>
                      <li>Idempotência por chave natural (marketplace + original_order_id): repetiu, não duplica.</li>
                      <li>Normalização de status, buyer e address: um vocabulário comum, relatórios coerentes.</li>
                      <li>DLQ e retry com política clara: erros ficam visíveis e reprocessáveis, não invisíveis.</li>
                      <li>Observabilidade por domínio: do webhook à query, tudo rastreável.</li>
                      <li>Contratos de leitura estáveis: paginação e metadados previsíveis para o frontend.</li>
                    </ul>
                    <h2>Como vamos construir (fases curtinhas)</h2>
                    <ul>
                      <li><b>Fase 1</b> — API de leitura do DB: já entrega valor. Listagem por marketplace, busca unificada, estatísticas e contratos estáveis.</li>
                      <li><b>Fase 2</b> — Ingestão e fila: primeiro marketplace (ex.: Shopee) com polling/webhook, publicação no RabbitMQ e consumer idempotente persistindo no PostgreSQL.</li>
                      <li><b>Fase 3</b> — Escala e visibilidade: novos marketplaces (Mercado Livre, Shein), métricas por fila, DLQ e reprocessamento guiado.</li>
                      <li><b>Fase 4</b> — Operação com confiança: segurança, gestão de segredos, backups, retenção e testes de carga.</li>
                    </ul>
                    <h2>Riscos que já esperamos (e como domar)</h2>
                    <ul>
                      <li>Payloads diferentes por marketplace → normalização canônica.</li>
                      <li>Rate limits e intermitência → retry/backoff e circuit breakers.</li>
                      <li>Duplicidades → idempotência com chaves naturais.</li>
                      <li>Filas crescendo → DLQ, monitoramento e reprocessamento controlado.</li>
                    </ul>
                    <h2>Próximos passos práticos</h2>
                    <ul>
                      <li>Congelar os contratos da API de leitura e alinhar o frontend.</li>
                      <li>Subir um marketplace ponta a ponta (ingestão → MQ → consumer → DB → leitura).</li>
                      <li>Habilitar métricas e dashboards mínimos (filas, DLQ, latências de consulta).</li>
                    </ul>
                    <hr>
                    <p>Se quiser mergulhar nos detalhes, os documentos de apoio trazem a vista completa sem código: <code>doc/ARQUITETURA.md</code> (topologia e sequências) e <code>doc/DESENVOLVIMENTO.md</code> (diretrizes de time). A história acima é o fio condutor: manter a leitura previsível, domesticar a ingestão e deixar a cidade vender em paz.</p>
                    <h2>Recursos e referências</h2>
                    <ul>
                      <li>Repositório (código-fonte): <a href="https://github.com/chmulato/hub_town" target="_blank" rel="noopener noreferrer">https://github.com/chmulato/hub_town</a></li>
                      <li>Artigo 1 (contexto e visão inicial): <a href="2025_09_28_hub_local_de_integracao_para_pequenas_cidades.html">2025_09_28_hub_local_de_integracao_para_pequenas_cidades.html</a></li>
                    </ul>
                    <details open id="adendo-dicionario">
                      <summary><small>Adendo — Dicionário técnico (para executivos)</small></summary>
                      <div class="adendo-content" style="font-size: 0.9em;">
                      <ul>
                        <li><b>Spring Boot:</b> plataforma Java para criar serviços rapidamente, com padrões de mercado já configurados.</li>
                        <li><b>RabbitMQ:</b> serviço de filas que desacopla partes do sistema e absorve picos de tráfego.</li>
                        <li><b>Exchange (topic):</b> componente que recebe mensagens e as distribui para filas conforme “rótulos” (routing keys).</li>
                        <li><b>Routing key:</b> rótulo da mensagem (ex.: orders.shopee.created) usado para decidir o destino.</li>
                        <li><b>Fila (Queue):</b> onde mensagens aguardam para serem processadas por consumidores.</li>
                        <li><b>DLQ (Dead-Letter Queue):</b> fila onde caem mensagens que falharam várias vezes; torna o erro visível e auditável.</li>
                        <li><b>TTL + DLX (Retries):</b> estratégia de “esperar e tentar de novo” usando tempo de vida (TTL) e redirecionamento automático (DLX).</li>
                        <li><b>Idempotência:</b> regra para não gravar duplicado quando a mesma informação chega mais de uma vez.</li>
                        <li><b>UPSERT:</b> operação que insere o registro se ele não existe, ou atualiza se já existe.</li>
                        <li><b>Fonte única da verdade:</b> banco central (PostgreSQL) do qual a leitura é sempre feita, garantindo consistência.</li>
                        <li><b>API de Leitura:</b> serviço que faz consultas ao banco e entrega dados prontos para o frontend.</li>
                        <li><b>Paginação e metadados:</b> respostas com total de itens e páginas, evitando cargas lentas e caras.</li>
                        <li><b>Busca unificada:</b> pesquisa que reúne pedidos de todos os marketplaces com um só contrato de resposta.</li>
                        <li><b>KPI:</b> indicador-chave (ex.: pedidos por status) usado para orientar decisões do dia a dia.</li>
                        <li><b>Observabilidade (logs, métricas, tracing):</b> visibilidade do que está acontecendo para agir rápido em incidentes.</li>
                        <li><b>Prefetch e Ack manual:</b> controle de “quantas mensagens por vez” e confirmação explícita só após salvar no banco.</li>
                        <li><b>Publisher Confirms:</b> confirmação de que a mensagem realmente entrou no RabbitMQ.</li>
                        <li><b>Quorum Queues:</b> tipo de fila mais resiliente (produção); Classic Queues: mais simples (desenvolvimento).</li>
                        <li><b>Schema canônico e normalização:</b> formato comum de dados para todos os marketplaces, reduzindo surpresas.</li>
                        <li><b>Circuit breaker e backoff:</b> proteções contra instabilidades externas e “tentativas mais espaçadas”.</li>
                        <li><b>Rate limit:</b> limite imposto por APIs de terceiros; deve ser respeitado com controle de chamadas.</li>
                        <li><b>Backlog de fila:</b> quantidade de mensagens pendentes; quando cresce, indica gargalos.</li>
                        <li><b>CorrelationId/TraceId:</b> identificadores para seguir a jornada de uma mensagem ponta a ponta.</li>
                        <li><b>“Última versão vence”:</b> quando chegam atualizações fora de ordem, vale a mais recente pelo timestamp.</li>
                      </ul>
                      </div>
                    </details>
                </div>
            </article>
        </div>
    </main>
    <footer class="site-footer">
        <div class="container">
            <p>&copy; 2025 Christian Mulato. Todos os direitos reservados.</p>
        </div>
    </footer>
    <script src="assets/js/main.js"></script>
</body>
</html>
