<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Do Mvc Para A Arquitetura Hexagonal - Uma Transição Necessária - Christian Mulato Dev Blog</title>
    <meta name="description" content="Artigo sobre Do Mvc Para A Arquitetura Hexagonal - Uma Transição Necessária">
    <meta name="author" content="Christian Mulato">
    <meta name="keywords" content="Java, Desenvolvimento, Tecnologia">
    
    <!-- CSS -->
    <link rel="stylesheet" href="assets/css/main.css">
    <link rel="stylesheet" href="assets/css/article.css">
    <link rel="stylesheet" href="assets/css/highlight.css">
</head>
<body>
    <header class="site-header">
        <div class="container">
            <h1><a href="../index.html">Christian Mulato Dev Blog</a></h1>
            <nav class="main-nav">
                <a href="../index.html">Início</a>
                <a href="#sobre">Sobre</a>
            </nav>
        </div>
    </header>

    <main class="main-content">
        <div class="container">
            <article class="post">
                <header class="post-header">
                    <h1 class="post-title">Do Mvc Para A Arquitetura Hexagonal - Uma Transição Necessária</h1>
                    <div class="post-meta">
                        <time datetime="2025-07-24">24/07/2025</time>
                        <span class="post-author">Por Christian Mulato</span>
                    </div>
                    
                </header>
                
                <div class="post-content">
                    <p><img alt="Do MVC para a Arquitetura Hexagonal." src="assets/img/2025_07_24_IMAGE_001.png" /></p>
<p>Do MVC para a Arquitetura Hexagonal.</p>
<p><a href="https://www.linkedin.com/in/chmulato/"><strong>Christian Mulato</strong></a></p>
<p>Desenvolvedor Java Sênior | Especialista em Back-end | Jakarta, Spring Boot, REST APIs, Docker | Engenheiro Químico</p>
<p>24 de julho de 2025</p>
<p><strong>Por que inventaram a Interface?</strong></p>
<p>No início da programação orientada a objetos, os desenvolvedores buscavam uma forma de criar sistemas mais flexíveis e fáceis de evoluir. Surgiu então a ideia de "interface": um contrato que define o que uma classe deve fazer, mas não como ela faz. Isso permitiu separar o "o que" do "como", facilitando a troca de implementações sem afetar o restante do sistema.</p>
<p>Imagine um sistema de pagamentos: você pode ter uma interface Pagamento e várias implementações --- cartão, boleto, pix. O código que usa a interface não precisa saber qual implementação está por trás, apenas que ela cumpre o contrato.</p>
<p>Essa ideia é a base da Arquitetura Hexagonal. Ao colocar interfaces (portas) entre o núcleo da aplicação e o mundo externo (adaptadores), garantimos que a lógica de negócio não dependa de detalhes de infraestrutura. Assim, mudamos bancos, APIs ou frameworks sem mexer no coração do sistema --- exatamente o que as interfaces sempre buscaram proporcionar.</p>
<p><strong>Introdução</strong></p>
<p>Durante muitos anos, o padrão <strong>MVC (Model-View-Controller)</strong> foi a principal escolha para estruturar aplicações web. Ele é simples, direto e fácil de ensinar. Mas conforme os sistemas crescem e as demandas mudam, muitos desenvolvedores se deparam com a necessidade de evoluir para arquiteturas mais flexíveis, como a <strong>Arquitetura Hexagonal (Ports and Adapters)</strong>.</p>
<p>Essa transição, embora poderosa, traz confusões e desafios reais de entendimento.</p>
<hr />
<p><strong>O que é o MVC (Model-View-Controller)</strong></p>
<p>O MVC separa a aplicação em três responsabilidades principais:</p>
<ul>
<li>
<p><strong>Model:</strong> Representa os dados e regras de negócio.</p>
</li>
<li>
<p><strong>View:</strong> Camada de apresentação.</p>
</li>
<li>
<p><strong>Controller:</strong> Lida com a entrada do usuário e coordena Model e View.</p>
</li>
</ul>
<p>Essa estrutura funciona bem para aplicações simples e monolíticas. O problema começa quando o negócio exige integração com múltiplos serviços, testes de unidade eficazes, trocas de UI, APIs, filas, eventos etc.</p>
<hr />
<p><strong>Por que repensar o MVC tradicional</strong></p>
<ul>
<li>
<p>O Controller acaba assumindo responsabilidades demais.</p>
</li>
<li>
<p>Dificuldade de isolar a lógica de negócio para testes.</p>
</li>
<li>
<p>Forte acoplamento com frameworks web (Spring MVC, JSF, etc).</p>
</li>
<li>
<p>Problemas na manutenção com o tempo.</p>
</li>
<li>
<p>Camadas da aplicação conhecem demais umas às outras.</p>
</li>
</ul>
<hr />
<p><strong>Introduzindo a Arquitetura Hexagonal</strong></p>
<p>A <strong>Arquitetura Hexagonal</strong>, proposta por Alistair Cockburn, reorganiza o sistema com foco no domínio e na inversão de dependências. Ela separa a lógica central (o núcleo da aplicação) de tudo que é externo, através de <strong>portas</strong> (interfaces) e <strong>adaptadores</strong> (implementações).</p>
<p><strong>Componentes principais</strong></p>
<ul>
<li>
<p><strong>Domínio / Núcleo:</strong> Lógica pura da aplicação (independente de banco, web, etc).</p>
</li>
<li>
<p><strong>Portas:</strong> Interfaces de entrada (driven) e saída (driving).</p>
</li>
<li>
<p><strong>Adaptadores:</strong> Controladores HTTP, repositórios, mensagens etc.</p>
</li>
</ul>
<p>Essa arquitetura permite:</p>
<ul>
<li>
<p>Testar o domínio sem precisar de banco ou servidor web.</p>
</li>
<li>
<p>Substituir frameworks com impacto mínimo.</p>
</li>
<li>
<p>Ter múltiplas interfaces para o mesmo núcleo (REST, CLI, gRPC)* [Vide rodapé].</p>
</li>
<li>
<p>Clareza entre <em>regra de negócio</em> e <em>infraestrutura</em>.</p>
</li>
</ul>
<hr />
<p><strong>Um exemplo simples</strong></p>
<p><strong>Em MVC</strong></p>
<pre><code>@RestController
public class PedidoController {
    @Autowired PedidoService service;
    @PostMapping("/pedidos")
    public ResponseEntity<Pedido> criar(@RequestBody PedidoDTO dto) {
        return ResponseEntity.ok(service.criar(dto));
    }
}</code></pre>
<p><strong>Em Hexagonal</strong></p>
<pre><code>public interface PedidoUseCase {
    Pedido criar(PedidoDTO dto);
}

public class PedidoApplicationService implements PedidoUseCase {
    private PedidoRepository repo;
    public Pedido criar(PedidoDTO dto) {
        // lógica de negócio aqui
    }
}</code></pre>
<p>E no adaptador REST:</p>
<pre><code>@RestController
public class PedidoRestAdapter {
    private final PedidoUseCase useCase;
    @PostMapping("/pedidos")
    public ResponseEntity<Pedido> criar(@RequestBody PedidoDTO dto) {
        return ResponseEntity.ok(useCase.criar(dto));
    }
}</code></pre>
<hr />
<p><strong>Os desafios da transição</strong></p>
<ol>
<li>
<p><strong>Desapego da estrutura em camadas (controller -&gt; service -&gt; repository)</strong></p>
</li>
<li>
<p><strong>Aprender a nomear portas, adaptadores e entidades de forma expressiva</strong></p>
</li>
<li>
<p><strong>Separar regras de negócio reais de lógica de infraestrutura</strong></p>
</li>
<li>
<p><strong>Evitar duplicação entre DTOs, entidades e objetos de domínio</strong></p>
</li>
<li>
<p><strong>Dominar a inversão de dependência com interfaces e injeção</strong></p>
</li>
<li>
<p><strong>Reeducar a equipe para pensar em termos de casos de uso</strong></p>
</li>
</ol>
<hr />
<p><strong>Conclusão</strong></p>
<p>Migrar do MVC tradicional para a Arquitetura Hexagonal é uma mudança de mentalidade. Exige esforço, mas traz benefícios significativos em projetos complexos e de longo prazo.</p>
<p>Não se trata apenas de trocar nomes ou empacotar camadas de forma diferente. É um compromisso com uma arquitetura centrada no domínio, desacoplada e com maior foco na longevidade da aplicação.</p>
<p>Aos poucos, você perceberá que:</p>
<ul>
<li>
<p>Seus testes ficam mais rápidos e significativos.</p>
</li>
<li>
<p>Seu código se torna mais expressivo e reutilizável.</p>
</li>
<li>
<p>Seu sistema se adapta mais facilmente a mudanças externas.</p>
</li>
</ul>
<p>A pergunta não é mais "<em>posso fazer isso com MVC?</em>", mas sim: "<em>minha lógica de negócio depende de algo que deveria ser externo?</em>"</p>
<hr />
<p><strong>Autor:</strong> Christian V. Uhdre Mulato (<a href="https://github.com/chmulato"><strong>GitHub</strong></a>)</p>
<p><strong>LinkedIn:</strong> <a href="http://linkedin.com/in/chmulato"><strong>linkedin.com/in/chmulato</strong></a></p>
<hr />
<p>O que são essas tecnologias?</p>
<p>REST: Um estilo de arquitetura para APIs que usa HTTP para comunicação entre sistemas, geralmente em formato JSON.</p>
<p>CLI: Command Line Interface, ou seja, interface de linha de comando, onde o usuário interage com o sistema por comandos de texto.</p>
<p>gRPC: Um framework moderno de comunicação remota criado pela Google, baseado em HTTP/2 e Protobuf, eficiente para integração entre serviços distribuídos.</p>
                </div>
                
                <footer class="post-footer">
                    <div class="author-info">
                        <img src="assets/img/foto_chri.jpg" alt="Christian Mulato" class="author-avatar">
                        <div class="author-details">
                            <strong>Christian Mulato</strong>
                            <p>Desenvolvedor Java e Arquiteto de Software</p>
                        </div>
                    </div>
                </footer>
            </article>
        </div>
    </main>

    <footer class="site-footer">
        <div class="container">
            <p>&copy; 2025 Christian Mulato. Todos os direitos reservados.</p>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="assets/js/main.js"></script>
</body>
</html>
