<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Do código ao valor em minutos: automação que acelera entregas e reduz riscos - Christian Mulato Dev Blog</title>
    <meta name="description" content="Automação do build ao login com Python, Jakarta EE, Tomcat e WildFly para reduzir atrito, ganhar previsibilidade e acelerar entregas.">
    <meta name="author" content="Christian Mulato">
    <meta name="keywords" content="Automação, Deploy, Jakarta EE, Tomcat, WildFly, Python, DevOps, JNDI, CI/CD, Playwright">
    <link rel="stylesheet" href="assets/css/main.css">
    <link rel="stylesheet" href="assets/css/article.css">
    <link rel="stylesheet" href="assets/css/highlight.css">
    <link rel="icon" href="assets/img/favicon.ico">
    <meta property="og:title" content="Do código ao valor em minutos: automação que acelera entregas e reduz riscos">
    <meta property="og:description" content="Fluxo automatizado fim a fim: banco de dados, build, deploy em Tomcat e WildFly e validação real de login.">
    <meta property="og:type" content="article">
    <meta property="og:image" content="assets/img/2025_10_26_IMAGE_001.png">
    <meta property="og:locale" content="pt_BR">
</head>
<body>
<header class="site-header">
  <div class="container">
    <h1><a href="../index.html">Christian Mulato Dev Blog</a></h1>
    <nav class="main-nav">
      <a href="../index.html">Início</a>
      <a href="#sobre">Sobre</a>
    </nav>
  </div>
 </header>
 <main class="main-content">
  <div class="container">
    <article class="post">
      <header class="post-header">
        <h1 class="post-title">Do código ao valor em minutos: automação que acelera entregas e reduz riscos</h1>
        <div class="post-meta">
          <time datetime="2025-10-26">26/10/2025</time>
          <span class="post-author">Por Christian Mulato</span>
        </div>
      </header>
      <div class="post-content">
        <p><img src="assets/img/2025_10_26_IMAGE_001.png" class="hero-image" alt="Automação do build e deploy: do código ao valor com previsibilidade."></p>
        <p><em>Figura — Automação do build e deploy: do código ao valor com previsibilidade.</em></p>

        <p>Empresas que lidam com aplicações corporativas costumam enfrentar o mesmo dilema: como transformar código em valor de negócio com rapidez e previsibilidade, sem aumentar riscos operacionais? Nosso time encarou esse desafio ao modernizar o fluxo de validação e publicação de uma aplicação Java baseada em Jakarta EE, rodando nos servidores de aplicação Tomcat e WildFly.</p>

        <p>O resultado é um processo automatizado, simples de acionar, que reduz o esforço manual e encurta o tempo entre “desenvolver” e “comprovar que funciona”.</p>

        <h3>O desafio</h3>

        <p>Ambientes de desenvolvimento e teste historicamente sofrem com passos manuais: configurar servidor, preparar banco, publicar o artefato, checar se a aplicação subiu e se o login funciona. Esse ciclo, quando repetido por cada pessoa do time, gera inconsistências, retrabalho e atrasos.</p>

        <h3>A nossa resposta</h3>

        <p>Criamos um orquestrador leve em Python que padroniza o caminho “do build ao login”. Em um único fluxo:</p>
        <ul>
          <li>prepara o ambiente de banco de dados;</li>
          <li>compila a aplicação;</li>
          <li>publica nos servidores Tomcat e WildFly, respeitando as particularidades de cada um;</li>
          <li>confirma que a aplicação está de pé e que o login realmente funciona.</li>
        </ul>

        <p>Tudo isso com logs claros e passos idempotentes, para que o mesmo comando funcione de forma confiável na sua máquina e no ambiente de testes.</p>

        <p><img src="assets/img/2025_10_26_IMAGE_002.png" alt="Fluxo fim a fim: banco de dados, build, deploy e validação de login."></p>
        <p><em>Figura — Fluxo fim a fim: banco de dados, build, deploy e validação de login.</em></p>

        <h3>O que muda no dia a dia</h3>
        <ul>
          <li>Menos atrito e menos passos manuais. O time deixa de “cuidar de servidor” para focar no que gera valor: produto e cliente.</li>
          <li>Feedback mais rápido. A verificação de “build + publicação + login” acontece em minutos e de forma repetível.</li>
          <li>Menos variabilidade entre máquinas. Padronização reduz “funciona aqui, mas não ali”.</li>
          <li>Diagnóstico mais objetivo. Quando algo falha, os logs mostram exatamente onde atuar.</li>
        </ul>

        <h3>Benefícios para o negócio</h3>
        <ul>
          <li>Velocidade com governança: acelerar entregas sem abrir mão de controle e visibilidade.</li>
          <li>Qualidade percebida: a validação fim a fim (inclusive login) evita surpresas em demonstrações e testes de aceitação.</li>
          <li>Produtividade: menos tempo montando ambiente, mais tempo entregando valor.</li>
          <li>Redução de risco: processos padronizados diminuem erros operacionais e retrabalho.</li>
        </ul>

        <h3>Padronização que habilita escala</h3>
        <p>Publicar em Tomcat ou em WildFly sempre teve diferenças práticas. Nosso fluxo isola essas particularidades em um roteiro único e confiável, o que facilita treinar o time, reproduzir resultados e escalar as entregas com previsibilidade.</p>

        <h3>O que está pronto hoje</h3>
        <ul>
          <li>Execução com um comando: build, publicação em Tomcat e WildFly e verificação de disponibilidade.</li>
          <li>Checagem de banco e credenciais de teste para garantir que “logar” funciona de ponta a ponta.</li>
          <li>Registro de evidências (logs) para auditoria e diagnóstico.</li>
        </ul>

        <h3>Como acionamos (menu simples)</h3>
        <p>Para o time, tudo acontece a partir de um menu único (<code>main.py</code>). É possível executar o fluxo completo em um passo (opção 12) ou rodar etapas específicas quando necessário.</p>

        <p><img src="assets/img/2025_10_26_IMAGE_003.png" alt="Opções do terminal (main.py)"></p>
        <p><em>Figura — Menu do orquestrador: opções de build, deploy e validação. A opção 12 executa o fluxo fim a fim.</em></p>

        <h3>Próximos passos</h3>
        <ul>
          <li>Levar o mesmo fluxo para uma esteira de CI/CD de forma leve.</li>
          <li>Expor indicadores simples (tempo de ciclo, taxa de sucesso) para orientar decisões.</li>
          <li>Reforçar padrões que facilitem auditoria e compliance sem burocracia.</li>
        </ul>

        <h3>Convite</h3>
        <p>Se você busca reduzir o tempo entre código e valor, mantendo governança e qualidade, vamos conversar. Nosso objetivo é que qualquer pessoa do time consiga validar uma release com confiança — e que essa confiança se traduza em melhores experiências para clientes e áreas de negócio.</p>

        <p>Saiba mais e acesse o código-fonte:</p>
        <p><a href="https://github.com/chmulato/app_jakarta" target="_blank" rel="noopener noreferrer">chmulato/app_jakarta</a></p>

  <section class="technical-section">
  <h2>Do build ao login em minutos: nosso fluxo de deploy automatizado com Python, Jakarta EE, Tomcat e WildFly</h2>
        <p>Nos últimos meses, investimos tempo para tornar o ciclo “build → deploy → validar” do nosso projeto Java com Jakarta EE não apenas mais rápido, mas também previsível, reprodutível e confiável em ambientes de desenvolvimento e teste. O resultado é um orquestrador em Python (<code>main.py</code>) que, com um único comando, faz o build do WAR, configura datasources por servidor, executa deploy “frio” no Tomcat e “quente” no WildFly, garante o banco de dados no ar e valida o login da aplicação tanto por HTTP quanto via navegador headless.</p>

        <p>Publicaremos este relato no dia 26 de outubro de 2025 porque acreditamos que automatizar o caminho “da estação de trabalho ao servidor de aplicação” é a forma mais direta de reduzir atrito entre código e feedback, acelerar iterações e aumentar a qualidade.</p>

        <h3>Por que construímos esse orquestrador</h3>
        <ul>
          <li>Reduzir tempo de setup e diagnóstico para cada desenvolvedor.</li>
          <li>Padronizar deployment entre Tomcat e WildFly, respeitando as particularidades de cada um.</li>
          <li>Validar a aplicação de ponta a ponta, desde JNDI até autenticação, em um único fluxo não interativo (ideal para ambientes de teste).</li>
          <li>Eliminar “falsos verdes”: não basta compilar, precisamos garantir que “logar” funciona.</li>
        </ul>

        <h3>O coração do projeto: <code>main.py</code></h3>
        <p>Nosso script principal é uma CLI que entende o contexto do projeto e executa operações idempotentes. Um destaque especial é a opção 12 (E2E):</p>
        <ul>
          <li>Para servidores antes de começar — Agora a opção 12 inicia parando Tomcat e WildFly se estiverem rodando, garantindo estado limpo.</li>
          <li>Garante banco de dados disponível (PostgreSQL via Docker Compose) — Faz health-check e aplica seed do usuário ADMIN para testes.</li>
          <li>Build consistente do WAR — Executa Maven com <code>clean package -DskipTests</code> e valida a saída.</li>
          <li>Deploy por servidor, respeitando o perfil de cada um — Tomcat: cold deploy (parar, limpar e subir com WAR novo). WildFly: hot deploy (scanner de <code>deployments</code> reprocessa o artefato).</li>
          <li>JNDI confiável e portável — Tomcat usa <code>java:comp/env/jdbc/PostgresDS</code> (Resource em <code>conf/context.xml</code>, com DBCP do próprio Tomcat). WildFly usa <code>java:/jdbc/PostgresDS</code> (datasource no <code>standalone.xml</code> + driver no módulo <code>org.postgresql</code>).</li>
          <li>Validação real de login — Primeiro tenta navegação real com Playwright (headless). Fallback HTTP robusto (form discovery simples + variações de parâmetros).</li>
          <li>Logs e diagnósticos — Log diário com nome padrão <code>YYYY_MM_DD_nome.log</code>. Heurísticas de logs do container para detectar bind do JNDI ou falhas de driver. Validação HTTP opcional de “status JNDI/DB”, se a app expõe algum endpoint de saúde.</li>
        </ul>

  <div class="callout"><strong>Dica:</strong> Use a opção 12 (E2E) para validar "fim a fim" em um único comando. Ela garante ambiente limpo, banco disponível, WAR implantado e login verificado.</div>

  <h3>Decisões técnicas que fizeram a diferença</h3>
        <ul>
          <li>Context path padronizado dentro do WAR — Usamos <code>META-INF/context.xml</code> para declarar o caminho da aplicação, garantindo consistência entre os servidores.</li>
          <li>JNDI por container, sem gambiarras — WildFly: <code>java:/jdbc/PostgresDS</code> (non-jta-data-source em <code>persistence.xml</code>). Tomcat: <code>java:comp/env/jdbc/PostgresDS</code> com <code>Resource</code> e <code>resource-ref</code> apropriados.</li>
          <li>Datasource Tomcat com a factory certa — A factory confiável é a do Tomcat: <code>org.apache.tomcat.dbcp.dbcp2.BasicDataSourceFactory</code>.</li>
          <li>Login realmente testável (e previsível) — Padronizamos BCrypt para <code>$2a$</code> (compatível com jBCrypt) e normalizamos hashes <code>$2b$/$2y$</code> existentes, evitando incompatibilidades silenciosas.</li>
          <li>Deploys mais seguros — Cold deploy no Tomcat evita “deployment a quente” incompleto. Reinício do WildFly quando mexemos no <code>standalone.xml</code> ou nos módulos, garantindo que a nova config seja aplicada.</li>
        </ul>

  <h3>Experiência do desenvolvedor</h3>
        <p>Tudo converge na opção 12: uma execução não interativa que faz o “fim a fim” e termina dizendo, com evidências, se seu build realmente subiu e logou. É o tipo de feedback que elimina idas e vindas manuais, e dá confiança para focar no que importa: evolução do produto.</p>

  <div class="callout"><strong>Nota:</strong> Se algo falhar, confira os logs gerados (padrão <code>YYYY_MM_DD_nome.log</code>) e os logs do container (bind de JNDI/driver). Eles mostram exatamente onde atuar.</div>

        <p>Principais checks feitos automaticamente:</p>
        <ul>
          <li>Docker Compose presente e PostgreSQL no ar.</li>
          <li>ADMIN de teste assegurado no banco (com hash compatível com jBCrypt).</li>
          <li>WAR gerado e implantado.</li>
          <li>JNDI OK em cada servidor (estático e em runtime, via logs).</li>
          <li>Login validado em navegador e HTTP com redirecionamento para <code>/dashboard</code>.</li>
        </ul>

        <h3>Uma rotina que evita quedas de produtividade</h3>
        <p>Se você já perdeu tempo porque:</p>
        <ul>
          <li>o datasource não “bindou” no Tomcat por causa de uma factory errada,</li>
          <li>o WildFly subiu com um módulo de driver incompleto,</li>
          <li>o WAR foi “implantado” mas a app não respondeu em <code>/login</code>,</li>
          <li>ou o hash de senha não bateu por uma sutileza do algoritmo,</li>
        </ul>
        <p>…então sabe a importância de um fluxo que antecipa e resolve esses problemas por você. Nosso script trata esses pontos e loga o suficiente para diagnosticar em minutos.</p>

        <h3>O que vem a seguir</h3>
        <ul>
          <li>CI leve (GitHub Actions) para rodar a opção 12 em um runner self-hosted de teste.</li>
          <li>Parâmetros de ambiente padronizados para ambientes múltiplos (DEV/QA/UAT).</li>
          <li>Health endpoints opcionais na app para JNDI/DB, expondo status interpretável.</li>
          <li>Empacotamento com Docker para ambientes “clean-room”.</li>
          <li>SSL/HTTPS local assistido e testes de conteúdo com Playwright mais ricos.</li>
        </ul>

        <h3>Principais aprendizados</h3>
        <ul>
          <li>Automatizar o “último quilômetro” do deploy local testa muito mais do que o build; testa o que o usuário final realmente vive.</li>
          <li>Pequenos detalhes (ex.: prefixo do BCrypt, factory do DBCP no Tomcat) têm impacto desproporcional quando não tratados.</li>
          <li>Ferramentas simples e estáveis (Python + requests + Playwright + Maven) são suficientes para orquestrar um setup multiplataforma com excelência.</li>
        </ul>

        <h3>Agradecimentos e convite</h3>
        <p>Esse trabalho nasce da colaboração entre quem desenvolve, opera e testa. Se este fluxo te inspirou, vamos trocar ideias sobre como levar essa automação para o seu contexto—seja unificando sua esteira de deploy local, suas validações de ambiente ou seus smoke tests.</p>
        <ul>
          <li>Quer ver como padronizar JNDI entre Tomcat e WildFly no seu projeto?</li>
          <li>Precisa acelerar o “tempo até o primeiro login” do seu time?</li>
          <li>Está pensando em transformar esse fluxo em um job de CI?</li>
        </ul>
        <p>Me chame. Adoro falar sobre isso.</p>

  </section>
  <p><strong>Hashtags</strong>: #JakartaEE #Tomcat #WildFly #Java #Python #DevOps #Automation #PostgreSQL #Playwright #DX #DeveloperExperience #E2E #Quality #Testing</p>
      </div>
      <footer class="post-footer">
        <div class="author-info">
          <img src="assets/img/foto_chri.jpg" alt="Christian Mulato" class="author-avatar">
          <div class="author-details">
            <strong>Christian Mulato</strong>
            <p>Desenvolvedor Java e Arquiteto de Software</p>
          </div>
        </div>
      </footer>
    </article>
  </div>
 </main>
 <footer class="site-footer">
  <div class="container">
    <p>&copy; 2025 Christian Mulato. Todos os direitos reservados.</p>
  </div>
 </footer>
 <script src="assets/js/main.js"></script>
</body>
</html>
