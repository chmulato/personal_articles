<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Artigo técnico sobre o recurso computacional">
    <meta name="author" content="Christian Mulato">
    <meta name="keywords" content="Desenvolvimento, Tecnologia, Programação">
    
    <!-- Open Graph -->
    <meta property="og:title" content="O Recurso Computacional">
    <meta property="og:description" content="Artigo técnico sobre o recurso computacional">
    <meta property="og:type" content="article">
    <meta property="og:author" content="Christian Mulato">
    <meta property="og:article:published_time" content="12/05/2024">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="O Recurso Computacional">
    <meta name="twitter:description" content="Artigo técnico sobre o recurso computacional">
    
    <title>O Recurso Computacional | Christian Mulato Dev Blog</title>
    
    <!-- Fonts e Styles -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=Fira+Code:wght@300;400;500;600&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="../assets/css/main.css">
    <link rel="stylesheet" href="../assets/css/article.css">
    
    <!-- Prism.js para syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet">
    
    <!-- Schema.org structured data -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "Article",
        "headline": "O Recurso Computacional",
        "description": "Artigo técnico sobre o recurso computacional",
        "author": {
            "@type": "Person",
            "name": "Christian Mulato"
        },
        "datePublished": "12/05/2024",
        "category": "DevOps & Containers"
    }
    </script>
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <a href="../index.html" class="nav-brand">← Voltar ao Blog</a>
            <div class="nav-links">
                <a href="../index.html">Artigos</a>
                <a href="https://www.linkedin.com/in/chmulato/" target="_blank">LinkedIn</a>
                <a href="https://github.com/chmulato" target="_blank">GitHub</a>
            </div>
        </div>
    </nav>

    <article class="article-container">
        <header class="article-header">
            <div class="article-meta">
                <span class="category">DevOps & Containers</span>
                <time class="date" datetime="12/05/2024">12/05/2024</time>
            </div>
            <h1 class="article-title">O Recurso Computacional</h1>
            <div class="author-info">
                <span>Por <a href="https://www.linkedin.com/in/chmulato/" target="_blank">Christian Mulato</a></span>
            </div>
            <div class="article-tags">
                <span class="tag">Desenvolvimento</span> <span class="tag">Tecnologia</span> <span class="tag">Programação</span>
            </div>
        </header>
        
        <div class="article-content">
            <p><img alt="O recurso computacional e os conceitos entre Stateless e Stateful." src="img/2024_05_12_O Recurso Computacional_image7.png" /></p>
<p>O recurso computacional e os conceitos entre Stateless e Stateful.</p>
<p>O Recurso Computacional</p>
<p><img alt="Christian Mulato" src="img/2024_05_12_O Recurso Computacional_image8.jpg" /></p>
<p>Christian Mulato</p>
<p>Desenvolvedor Java Sênior na Develcode</p>
<p>12 de maio de 2024</p>
<p>Recurso computacional refere-se a equipamentos, softwares e arquivos digitais que são administrados, mantidos ou operados pela área de Tecnologia da Informação (TI). Isso inclui computadores pessoais, servidores de rede, terminais, impressoras, redes de computadores, bancos de dados, sistemas desenvolvidos internamente ou por terceiros, entre outros. Esses recursos são essenciais para o funcionamento de sistemas complexos, desde aplicativos básicos em dispositivos móveis até supercomputadores usados em pesquisas científicas avançadas.</p>
<p>A relação entre recurso computacional e os conceitos de stateful e stateless está relacionada à persistência de informações. Um recurso computacional é considerado stateful quando mantém um estado interno, ou seja, armazena informações sobre o contexto ou histórico de interações. Por exemplo, um servidor de banco de dados que registra transações ou um aplicativo de mensagens que rastreia conversas é stateful. Por outro lado, um recurso stateless não mantém estado entre solicitações, sendo independente de qualquer contexto anterior. Exemplos incluem servidores web que respondem a solicitações sem armazenar informações específicas do cliente. A escolha entre stateful e stateless depende das necessidades do sistema e da eficiência desejada .</p>
<p>Para a arquitetura de desenvolvimento de software, os termos stateless e stateful desempenham papéis cruciais. Vamos focar no stateless. Uma aplicação ou processo stateless é composto por recursos isolados. Nenhuma referência ou informação sobre transações antigas é armazenada, e cada interação é tratada do zero. Essas aplicações fornecem funções ou serviços e utilizam a rede de entrega de conteúdo (CDN), a web ou servidores de impressão para processar solicitações a curto prazo. Por exemplo, uma pesquisa online que você faz para tirar dúvidas é uma transação stateless: você digita sua consulta, pressiona enter e, se a transação for interrompida, precisará começar outra. Transações stateless são como máquinas de vendas automáticas: você faz uma solicitação e recebe uma resposta. Já as aplicações stateful mantêm contexto e histórico, permitindo retomar transações onde pararam. Imagine-as como uma conversa contínua com a mesma pessoa. A maioria das aplicações diárias é stateful, enquanto os avanços tecnológicos, como microsserviços e containers, facilitam a criação e implantação de aplicações na nuvem.</p>
<p>Stateless e Stateful: O Que Significam?</p>
<ul>
<li>Stateless (sem estado): Aplicações ou processos stateless são recursos isolados. Eles não armazenam informações sobre transações anteriores e cada interação é tratada do zero. Essas aplicações fornecem funções ou serviços e usam a rede de entrega de conteúdo (CDN), a web ou servidores de impressão para processar solicitações a curto prazo. Um exemplo de transação stateless é uma pesquisa online em que você digita uma consulta no mecanismo de busca e pressiona “enter”. Se a transação for interrompida, você precisará começar outra. As transações stateless são como máquinas de vendas automáticas: você faz uma solicitação e recebe uma resposta.</li>
<li>Stateful (com estado): Aplicações e processos stateful podem ser usados mais de uma vez, como e-mails e serviços bancários online. Eles são executados com base no contexto das transações anteriores. O estado dessas aplicações é mantido, permitindo que você retome uma transação de onde parou. Por exemplo, se você estiver realizando uma transação bancária online e ela for interrompida, poderá retomá-la exatamente de onde parou, pois o contexto e o histórico são armazenados. As aplicações stateful acompanham informações como localização da janela, preferências de configuração e atividades recentes. Pense em transações stateful como uma conversa contínua com a mesma pessoa.</li>
</ul>
<p>Curiosidade</p>
<p>A especificação Java EE trata o estado stateless de maneira interessante. Vamos explorar um pouco mais sobre isso:</p>
<ul>
<li>Stateless Session Beans: Esses beans não mantêm um estado de conversação com o pedido. Quando um pedido invoca os métodos de um bean stateless, as variáveis de instância do bean podem conter um estado específico para aquele pedido, mas apenas durante a duração da invocação. Após a conclusão do método, o estado específico do pedido não deve ser retido.</li>
</ul>
<p><img alt="Imagem do artigo" src="img/2024_05_12_O Recurso Computacional_image9.png" /></p>
<p>Exemplo esquemático em camada de classes em Java EE com acesso a um recurso Stateless</p>
<p>Em outras palavras, os stateless session beans são projetados para serem efêmeros e sem memória. Eles não armazenam informações de estado entre chamadas de método, o que os torna ideais para processamento rápido e eficiente. Por exemplo, em um cenário de aplicativo da web, um bean stateless pode ser usado para executar operações de cálculo ou acesso a banco de dados sem a necessidade de manter informações de sessão específicas do pedido.</p>
<p>Essa abordagem é especialmente útil quando se lida com tarefas que não exigem rastreamento de estado contínuo, como autenticação, validação de dados ou cálculos matemáticos. Portanto, os beans stateless são uma escolha poderosa para otimizar o desempenho e a escalabilidade em aplicativos Java EE.</p>
<p>Conclusão</p>
<p>Em resumo, a escolha entre stateless e stateful depende das necessidades específicas da aplicação e dos recursos disponíveis. Ambos têm seus usos específicos para cada estratégia adotada, e a evolução tecnológica continua a moldar essa dinâmica entre os dois conceitos.</p>
        </div>
    </article>

    <footer class="article-footer">
        <div class="footer-content">
            <p>&copy; 2025 Christian Mulato. Todos os direitos reservados.</p>
            <div class="footer-links">
                <a href="https://www.linkedin.com/in/chmulato/" target="_blank">LinkedIn</a>
                <a href="https://github.com/chmulato" target="_blank">GitHub</a>
            </div>
        </div>
    </footer>
    
    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
    
    <!-- Copy code functionality -->
    <script>
        // Adicionar botões de copiar código
        document.querySelectorAll('pre code').forEach((block) => {
            const button = document.createElement('button');
            button.className = 'copy-button';
            button.textContent = 'Copiar';
            button.onclick = () => {
                navigator.clipboard.writeText(block.textContent);
                button.textContent = 'Copiado!';
                setTimeout(() => button.textContent = 'Copiar', 2000);
            };
            block.parentNode.appendChild(button);
        });
    </script>
</body>
</html>